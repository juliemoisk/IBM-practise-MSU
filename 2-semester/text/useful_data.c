//-----------------------------------------------------------------------------------------------------------------------------------
int main (void)   //создаем строку состоящую из алфавита
{
  char abc[256];               // хватит 27, тип abc -  char * const 
  int i;
  for (i = 0; i < 26; ++i)
  	abc[i] = 'A' + i;
  abc[i] = '\0';
  printf ("Алфавит: %s\n", abc);
  return 0;
}
//-----------------------------------------------------------------------------------------------------------------------------------
int main (void)
{
  int i;
  char * abc = (char *) malloc(27);            // тип abc - char * 
  if (abc == NULL) 
  {
    fprintf(stderr, "Ошибка выделения памяти\n");
    return 1;
  }
  for (i = 0; i < 26; ++i)
  {
  	abc[i] = 'A' + i;
  }
  abc[i] = '\0';
  printf ("Алфавит: %s\n", abc);
  free(abc);
  return 0;
}
//-----------------------------------------------------------------------------------------------------------------------------------
strlen - вычислить длину строки
  int strlen (char * string)
Функция возвращает длину в байтах строки, адрес которой определяется значением параметра string, не учитывая нулевой символ.
//-----------------------------------------------------------------------------------------------------------------------------------
strcpy - копировать одну строку в другую
  char * strcpy (char * to, char * from)

копирует ограниченное число символов.
char * strncpy (char * to, const char * from, size_t size)
//-----------------------------------------------------------------------------------------------------------------------------------
strcat - конкатенация (склеивание) строк
  char * strcat (char * to, char * from)

char * strncat (char * to, const char * from, size_t size)
//-----------------------------------------------------------------------------------------------------------------------------------
strcmp - сравнить две строки
  int strcmp (char * s1, char * s2)

Функция сравнивает строки, адреса которых задаются значениями аргументов s1 и s2, лексикографически (в алфавитном порядке) 
и возвращает значение, определяющее их соотношение:

        меньше 0        s1 меньше, чем s2
        0               s1 идентична s2
        больше 0        s1 больше, чем s2

Значение имеет тот же знак, что и различие между первой отличающейся парой символов (интерпретируемых как объекты char без знака).

Следствием упорядочения, используемого strcmp, является то, что если s1 является начальной подстрокой s2, то s1 "меньше чем" s2. 

int strncmp (const char *sl, const char *s2, size_t n)
//-----------------------------------------------------------------------------------------------------------------------------------
#include <stdlib.h>
atof - преобразует символьную строку в значение типа float;
atoi - преобразует символьную строку в значение типа int;
atol - преобразует символьную строку в значение типа long int;
strtod - преобразует символьную строку в значение типа double;
strtol - преобразует символьную строку в значение типа long int.

double atof(const char * string)
int atoi(const char * string)
int atol(const char * string)

Если функция не в состоянии преобразовать символьную строку в числовое значение, то возвращается значение 0. 
Если на входе функции встречается неподходящий символ (например, буква), выполнение преобразования прерывается и 
возвращается значение, вычисленное до появления этой литеры в строке.

double strtod(const char * string, char ** endptr)
long int strtol(const char * string, char ** endptr, int base)

Функция strtod преобразовывает строку string в double.
Функция strtol преобразовывает строку string в long int.

Если endptr не является нулевым указателем, то обе функции устанавливают значение endptr на первый символ после найденного числа 
(на остаток строки, который не удалось интерпретировать).

base - основание системы счисления;
если 0, число может быть и восьмеричным, и десятичным, и шестнадцатеричным;
другое - от 2 до 36 (используются буквы a/A-z/Z).
//-----------------------------------------------------------------------------------------------------------------------------------

isalnum - проверка алфавитно-цифрового символа. Прописная буква от А до Z, строчная буква от а до z или цифра от 0 до 9. 

#define isalnum(c) ( (toupper((с)) >= 'А' && toupper ((с)) <= 'Z') || ((с) >= '0' && (с) <= '9') )
//-----------------------------------------------------------------------------------------------------------------------------------
isalpha - проверка буквы алфавита (прописной или строчной).
Буквы от А до Z или от а до z. 

#define isalpha(с) ( toupper((с)) >= 'А' && toupper((с)) <= 'Z' )
//-----------------------------------------------------------------------------------------------------------------------------------
isdigit - проверка символа-цифры. 
ASCII-значение из диапазона от '0' до '9'.

#define isdigit(c) ( (c) >= '0' &&  (c) <= '9' )
//-----------------------------------------------------------------------------------------------------------------------------------
islower и isupper - проверка буквы: прописная или строчная.
Буквы нижнего или верхнего регистра соответственно. 

#define islower(c) ( (с) >= 'а' && (с) <= 'z' )
#define isupper(c) ( (с) >= 'А' && (с) <= 'Z' )
//-----------------------------------------------------------------------------------------------------------------------------------
ispunct - проверка знаков пунктуации.
Любые ASCII-символы, не являющиеся алфавитно-цифровыми.

#define ispunct(с) ( isgraph((c)) && ! isalnum((с)) )
#define isgraph(ltr) ( (ltr) >= 33) && (ltr) <= 127 )

isspace - проверка пробельных символов. 
Символы пробела (' ', код 32), горизонтальной табуляции ('\t', код 9), 
возврата каретки (возврат к началу строки) ('\r', код 13), 
перевода строки ('\n', код 10), вертикальной табуляции ('\v', код 11) 
и прогона страницы ('\f', код 12). 

#define isspace(с) ( (с) == 32 || (с) == 9 || (с) == 13 || (c) == 10 || (c) == 11 || (c) == 12 )
//-----------------------------------------------------------------------------------------------------------------------------------
isxdigit - проверка шестнадцатеричной цифры. 
Цифра из диапазона 0-9 или буква от А до F или от а до f.

#define isxdigit(c) ( isdigit((с)) || (toupper((с)) >= 'А' && toupper((с)) <= 'F') )
//-----------------------------------------------------------------------------------------------------------------------------------

int _toupper(int character);
int toupper(int character);

Макрокоманда _toupper не выполняет проверку преобразуемого символа, которая бы гарантировала, что символ является буквой нижнего регистра. 
Если обратиться к макрокоманде с символом, не являющимся буквой нижнего регистра, то произойдет ошибка. 
Функция toupper преобразует только те символы, которые являются буквами нижнего регистра, оставляя все другие символы без изменения. 
Если есть уверенность, что символ содержит букву нижнего регистра, то лучше использовать макрокоманду _toupper - она выполняется быстрее, чем функция. 
Однако если точно не известно, что символ является буквой нижнего регистра, следует использовать функцию toupper. 

Преобразование символа к нижнему регистру. 
Макрокоманда _tolower определена в заголовочном файле ctype.h. 
Функция Си-библиотеки tolower. 

int _tolower(int character);
int tolower(int character);
//-----------------------------------------------------------------------------------------------------------------------------------

Функции strchr и index

сhar * strchr (const char * string, int c)
char * index (const char * string, int c) - другое имя для strchr.

Функция strchr находит первое вхождение символа с (преобразованного в char) 
в строке с нулевым символом в конце, начинающейся в string. 
Возвращаемое значение - указатель на символ или NULL, 
если соответствие не было найдено.

      strchr ("привет, мир", 'в')         //     привет, мир\0
      => "вет, мир"                       //        ^  
      strchr ("привет, мир", '?')
      => NULL

Символ '\0' является частью строки, 
так что можно использовать эту функцию для получения указателя на конец строки, 
беря '\0' в качестве второго аргумента.
//-----------------------------------------------------------------------------------------------------------------------------------
Функции strrchr и rindex

сhar * strrchr (const char * string, int c)
char * rindex (const char * string, int c) - другое имя для strrchr.

Функция strrchr подобна strchr, но она ищет в обратном направлении, 
с конца строки, а не с начала.

      strrchr ("привет, мир", 'и')
      => "ир"
//-----------------------------------------------------------------------------------------------------------------------------------
Функция strstr

char * strstr (const char * string, const char * sub)

Функция ищет в string подстроку sub. 
Она возвращает указатель в строке string, 
который является первым символом подстроки, 
или NULL, если соответствия не было найдено. 
Если sub - пустая строка, то функция возвращает string.

      strstr ("привет, мир", "в")
      => "вет, мир"
      strstr ("привет, мир", "ми")
      => "мир"
//-----------------------------------------------------------------------------------------------------------------------------------
Функция strspn

size_t strspn (const char * string, const char * set) 

Функция strspn возвращает длину начальной подстроки строки, 
которая состоит полностью из символов, 
которые являются элементами набора, заданного строкой set. 
Порядок символов в set не важен.

      strspn ("привет, мир", "абвгдежзийклмнопрстуфхцчшщъыьэюя")
      => 6
//-----------------------------------------------------------------------------------------------------------------------------------
Функция strcspn
      
size_t strcspn (const char * string, const char * set)

Функция strcspn возвращает длину начальной подстроки строки, 
которая состоит полностью из символов, которые не принадлежат набору, 
заданному строкой set, другими словами, 
смещение к первому символу из набора set.

      strcspn ("привет, мир", "\t\n,.;!?")
      => 6
//-----------------------------------------------------------------------------------------------------------------------------------
Функция strpbrk (string pointer break)

char * strpbrk (const char * string, const char * breakset)

strpbrk возвращает указатель на первый символ в строке, 
который является элементом набора breakset.
Функция возвращает NULL, если никакой символ из breakset не найден.

      strpbrk ("привет, мир", "\t\n,.;!?")
      => ", мир"
//-----------------------------------------------------------------------------------------------------------------------------------
Функция strtok

char * strtok (char *str, const char * sep);

str – указатель на разбиваемую строку,
sep – указатель на строку, содержащую набор символов-разделителей.

Функция strtok разбивает строку str на серию токенов (слов), используя набор символов-разделителей sep. При первом вызове функции strtok 
указываются начало разделяемой строки (str) и начало строки, содержащей разделители (sep). Возвращается указатель на первый токен (обычно начало str).
Чтобы найти начало следующего слова, нужно вызвать strtok с первым параметром NULL. Будут возвращаться указатели
на следующие слова. Вызов strtok модифицирует строку str,после очередного слова появляется символ '\0' (заменяющий
символ из sep). Когда слов больше нет, возвращается NULL.

#include <string.h>

int main(void)
{
  char str[] = "Рассмотрим, например, эту  строку.";
  char * pch;
  printf("Разобьём строку \"%s\" на слова:\n", str);
  pch = strtok(str, " .,");
  while (pch != NULL)
  {
    printf("%s\n", pch);
    pch = strtok(NULL, " .,");
  }
  return 0;
}

Рассмотрим, например, эту  строку.\0
Рассмотрим\0 например\0 эту\0 строку\0

Рассмотрим
например
эту
строку
//-----------------------------------------------------------------------------------------------------------------------------------
